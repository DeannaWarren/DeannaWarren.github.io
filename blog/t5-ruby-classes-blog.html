<!DOCTYPE html>
<!-- This is a template for the layout of the page of a blog post-->
<html>
<head>
  <title>Deanna Warren</title>
  <meta charset="UTF-8">
  <link href='https://fonts.googleapis.com/css?family=Fondamento' rel='stylesheet' type='text/css'>
  <link href='https://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" type="text/css" href="../Stylesheets/default.css">
  <link rel="stylesheet" type="text/css" href="../Stylesheets/blog-post.css">
</head>
<body>
 <header>
     <H1><a href="http://deannawarren.github.io">Deanna Warren </a></H1>
    <H2> Dev Bootcamp Student </H2>
  </header>
  <nav>
    <ul>
    <li><a href="http://deannawarren.github.io/blog/index.html"> Blog </a></li>
    <li><a href="#"> Portfolio (Coming soon!) </a></li>
    <li><a href="#"> About Me  (Coming soon!)</a></li>
    <li><a href="#"> Resume  (Coming soon!)</a></li>
    <li><a href="../personal-info/contact-me.html"> Contact </a></li>
    </ul>
  </nav>
  <main>
    <section>
      <H2>Classes in Ruby</H2>
      <H3>Or "How is a Toaster like a Programming Desk"</H3>
      <h4>10/18/15</h4>
      <p>How is a Raven like a Writing Desk? or more appropriately, how is a toaster like a programming desk, that is to say relevent in any way to programming? Classes in Ruby are a way of catagorizing specific things by a group of methods showing different actions that item can take. I shall be showing this using ... you guessed it... a toaster. That is to say, toasters.</p>
      <code><pre>
        class Toaster
          def initialize(slice=2)
            #creates a new toaster with a set number of slices allowed
            #the default is two slices
            #if we don't tell it how many slices, it will be two
          end
        end
      </pre></code>
      <p>The code above initializes, or creates, a new instance of the class Toaster when we type "variable_name = Toaster.new". We won't get into it much today, but most methods in a class are called literally, aka "Toaster.method". ".new" for initialize is different, but it's a bit confusing, and better to just know it's true. </p>
      <p>Now, what do toasters do? You may say "They toast!" but that's a simple way to put it. There are a number of things you can do, and I'll code them out and walk through just a few of our options.</p>
      <p>FEEL FREE TO SKIP THE CODE IF YOU LIKE, I SHALL PICK UP ON THE OTHER SIDE</p>
      <code><pre>
        class Toaster
          attr_reader :slices, :crumbs, :setting

          def initialize(slices=2, setting=3)
            @slices = slices
            puts "The toaster has #{@slices} number of slices availible."
            if setting > 0 && setting < 6
              @setting = setting
            else
              puts "Setting must be between 1 and 5. Setting will be set to default."
              @setting = 3
            end
            @crumbs = 0
          end

          def change_setting(new_setting)
            if new_setting == @setting
              puts "The desired setting is the same, and has not changed"
            elsif setting > 0 && setting < 6
              @setting = new_setting
              puts "Setting has been set to #{@setting}"
            else
              puts "Setting must be between 1 and 5. Setting has not changed."
            end
          end

          def toast
            puts "#{@slices} of toast have been toasted"
            @crumbs += @slices
          end

          def is_clean
            if @crumbs == 0
              puts "The toaster is very clean"
            elsif @crumbs < 10
              puts "The toaster is a little messy."
            else
              puts "The toaster needs cleaning!"
            end
          end

          def clean
            @crumbs = 0
            puts "Yay! The toaster is clean!"
          end

        end
      </pre></code>
      <p>So to walk through the basics, the first thing we did was tell it to make itself, like we did before. You may have noticed "attr_reader" and gone, whoa! What even is that?! Basically, that allows you to simply call the variable like a method. attr_reader, such as this, simply give you the value of that variable. attr_writers allow for the variable to be changed, and attr_accessors allow both. I used reader because one of my variables is a constant that you may want to check (you cannot change the slice count on a toaster on a whim!), and the other two have specific methods to change them(change_setting must return a certain range, and crumbs can only be reset to 0 by using 'clean').</p>
      <p>The change_setting method is basically the dial on the front. If you attempt to set it to a setting that dosn't exist, or to the current setting, it won't change. That's because that wouldn't make any sense. The toast method (of which I'm particularly proud and amused) returns a notice of toast made, and also increases the number of crumbs in the toaster, for another level of reality. To really bring it home though, we have to add is_clean, to ask the toaster whether it has crumbs (or lots of crumbs!). And then of course, we need to clean it by returning the crumb count to 0!</p>
      <p>In summary, and as a reminder, Classes in ruby consist of a group of objects sharing similar functions and characteristics. In my case, you can make a two slot toaster, and a 27 slice toaster, but they're going to come down to the same things in the end. </p>
    </section>
  </main>
<footer>
    <p>Deanna Warren (2015)</p>
  </footer>
</body>
</html>