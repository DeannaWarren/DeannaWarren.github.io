<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Deanna Warren</title>
    <link rel="stylesheet" href="/css/app.css" />
    <script src="/bower_components/modernizr/modernizr.js"></script>
  </head>
  <body>

  <header class="text-center">
     <H1><a href="/index.html">Deanna Warren </a> </H1>
  </header>
  <nav class="row text-center">
    <ul class="button-group round">
      <li><a href="/blog/index.html" class="button" role="button"> Blog </a></li>
      <li><a href="/portfolio/index.html" class="button" role="button"> Portfolio  </a></li>
      <li><a href="/personal-info/about-me.html" class="button" role="button"> About Me </a></button></li>
      <li><a href="/personal-info/contact-me.html" class="button" role="button"> Contact </a></li>
    </ul>
  </nav>
  <main class="row">
    <article>
      <H2>
        Enumerable Method (ruby)- minmax - min, max, and minmax - 10-11-15
      </H2>
      <p><em>
        DISCLAIMER: THE FOLLOWING IS FROM A SERIES OF POST MADE DURING THE FIRST HALF OF MY TIME AT DEV BOOT CAMP, AND THEREFORE MAY CONTAIN INCONSISTENCIES AND MISINFORMATION AS THEY ARE WRITTEN IN THE WEEK I LEARN A NEW CONCEPT. TAKE WITH A GRAIN OF SALT.
      </em></p>
      <p>
        Now that we're learning ruby, let's talk enumerable methods! Or ... not? I'm not going to lie. Both things we did this week (enumerables and making classes for objects) still make almost no sense on a larger scale, but I can do/use them, and that's really the worthier part. Understanding comes with use, right?
      </p>
      <p>
        To make our lives a little simpler, why don't we just focus on .max? Well, if we're going to talk about max, we may as well mention it's "siblings" (conceptually, not a code term): .min, and .minmax. The names are pretty self explanitory but for further clarity: min returns the object of minimum value, max does the same for maximum value, and minmax returns a two object array with both.
      </p>
      <p>
        So what would that look like? Why don't we take a few examples? Let's take some example arrays, one with strings, one with integers. We'll do the same with hashes. I'm going to set the keys on the string hash to strings, so we can see whether the min/max/minmax family works on keys or values.
      </p>
      <code><pre>
        string_array = ["this", "is", "a", "basic", "sentence"]
        integer_array = [42, 4, 12, 24, 5]
        string_hash = {"this" => 42, "is" => 4, "a" => 12, "basic" => 24, "sentence" => 5}
        integer_hash = {42 => "this", 4 => "is", 12 => "a", 34 => "basic", 5 => "sentence"}
      </pre></code>
      <p>
        So what happens if we call min on each of these? Will min return the same on both array and hash?
      </p>
      <code><pre>
        p string_array.min
          #output: "a"
        p integer_array.min
          #output: "4"
        p string_hash.min
          #output: ["a", 12]
        p integer_hash.min
          #output: [4, "is"]
      </pre></code>
      <p>
        As we can see, .min works on the key (or first item in the paired object) of a hash. We can therefore assume that .max will return "sentence" and 42.
      </p>
      <code><pre>
        p string_array.max
          #output: "this"
        p integer_array.max
          #output:42
        p string_hash.max
          #output: ["this", 42]
        p integer_hash.max
          #output: ["this", 42]
      </pre></code>
      <p>
        Well isn't that interesting! Why would it return "this" instead of "sentence"? Ruby assigns values to each object it contains. However, if we apply a different implementation, and a .length method, we can quickly find it.
      </p>
      <code><pre>
        p string_array.max{ |a, b| a.length <=> b.length }
          #output: "sentence"
      </pre></code>
      <p>
       We'll quickly run a minmax, to also see what that looks like.
      </p>
      <code><pre>
        p string_array.minmax{ |a, b| a.length <=> b.length }
          #output: ["a", "sentence"]
        p integer_array.minmax
          #output: [4, 42]
        p string_hash.minmax{ |a, b| a.length <=> b.length }
          #output: [["this", 42], ["this", 42]]
        p integer_hash.minmax
          #output: [[4, "is"], [42, "this"]]
      </pre></code>
      <p>
        So to put it simply, if you pay attention, and don't get overly wrapped up in fiddly bits of thought and not noticing some practical effects such as needing .length to work out with strings, this family of enumerable methods is fairly simple, and yet extremely helpful in many cases.
      </p>
    </article>
  </main>

  <footer class="text-center">
    <p>Deanna Warren (2015)</p>
  </footer>

    <script src="bower_components/jquery/dist/jquery.min.js"></script>
    <script src="bower_components/foundation/js/foundation.min.js"></script>
    <script src="js/app.js"></script>
  </body>
</html>
