<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Deanna Warren</title>
    <link rel="stylesheet" href="/css/app.css" />
    <script src="/bower_components/modernizr/modernizr.js"></script>
  </head>
  <body>

  <header class="text-center">
     <H1><a href="/index.html">Deanna Warren </a> </H1>
  </header>

  <nav class="row text-center">
    <ul class="button-group round">
      <li><a href="/blog/index.html" class="button" role="button"> Blog </a></li>
      <li><a href="/portfolio/index.html" class="button" role="button"> Portfolio  </a></li>
      <li><a href="/about-me/about-me.html" class="button" role="button"> About Me </a></button></li>
      <li><a href="/about-me/contact-me.html" class="button" role="button"> Contact </a></li>
    </ul>
  </nav>

  <main class="row">
    <article>
      <H2>
        Classes in Ruby - Or "How is a Toaster like a Programming Desk" - 10/18/15
      </H2>
      <p><em>
        DISCLAIMER: THE FOLLOWING IS FROM A SERIES OF POST MADE DURING THE FIRST HALF OF MY TIME AT DEV BOOT CAMP, AND THEREFORE MAY CONTAIN INCONSISTENCIES AND MISINFORMATION AS THEY ARE WRITTEN IN THE WEEK I LEARN A NEW CONCEPT. TAKE WITH A GRAIN OF SALT.
      </em></p>
      <p>
        How is a Raven like a Writing Desk? or more appropriately, how is a toaster like a programming desk, that is to say relevent in any way to programming? Classes in Ruby are a way of catagorizing specific things by a group of methods showing different actions that item can take. I shall be showing this using ... you guessed it... a toaster. That is to say, toasters.
      </p>
      <code><pre>
        class Toaster
          def initialize(slice=2)
            #creates a new toaster with a set number of slices allowed
            #the default is two slices
            #if we don't tell it how many slices, it will be two
          end
        end
      </pre></code>
      <p>
        The code above initializes, or creates, a new instance of the class Toaster when we type "variable_name = Toaster.new". We won't get into it much today, but most methods in a class are called literally, aka "Toaster.method". ".new" for initialize is different, but it's a bit confusing, and better to just know it's true.
      </p>
      <p>
        Now, what do toasters do? You may say "They toast!" but that's a simple way to put it. There are a number of things you can do, and I'll code them out and walk through just a few of our options.
      </p>
      <p>
        FEEL FREE TO SKIP THE CODE IF YOU LIKE, I SHALL PICK UP ON THE OTHER SIDE
      </p>

      <code><pre>
        class Toaster
          attr_reader :slices, :crumbs, :setting

          def initialize(slices=2, setting=3)
            @slices = slices
            puts "The toaster has #{@slices} number of slices availible."
            if setting > 0 && setting < 6
              @setting = setting
            else
              puts "Setting must be between 1 and 5. Setting will be set to default."
              @setting = 3
            end
            @crumbs = 0
          end

          def change_setting(new_setting)
            if new_setting == @setting
              puts "The desired setting is the same, and has not changed"
            elsif setting > 0 && setting < 6
              @setting = new_setting
              puts "Setting has been set to #{@setting}"
            else
              puts "Setting must be between 1 and 5. Setting has not changed."
            end
          end

          def toast
            puts "#{@slices} of toast have been toasted"
            @crumbs += @slices
          end

          def is_clean
            if @crumbs == 0
              puts "The toaster is very clean"
            elsif @crumbs < 10
              puts "The toaster is a little messy."
            else
              puts "The toaster needs cleaning!"
            end
          end

          def clean
            @crumbs = 0
            puts "Yay! The toaster is clean!"
          end

        end
      </pre></code>
      <p>
        So to walk through the basics, the first thing we did was tell it to make itself, like we did before. You may have noticed "attr_reader" and gone, whoa! What even is that?! Basically, that allows you to simply call the variable like a method. attr_reader, such as this, simply give you the value of that variable. attr_writers allow for the variable to be changed, and attr_accessors allow both. I used reader because one of my variables is a constant that you may want to check (you cannot change the slice count on a toaster on a whim!), and the other two have specific methods to change them(change_setting must return a certain range, and crumbs can only be reset to 0 by using 'clean').
      </p>
      <p>
        The change_setting method is basically the dial on the front. If you attempt to set it to a setting that dosn't exist, or to the current setting, it won't change. That's because that wouldn't make any sense. The toast method (of which I'm particularly proud and amused) returns a notice of toast made, and also increases the number of crumbs in the toaster, for another level of reality. To really bring it home though, we have to add is_clean, to ask the toaster whether it has crumbs (or lots of crumbs!). And then of course, we need to clean it by returning the crumb count to 0!
      </p>
      <p>
        In summary, and as a reminder, Classes in ruby consist of a group of objects sharing similar functions and characteristics. In my case, you can make a two slot toaster, and a 27 slice toaster, but they're going to come down to the same things in the end.
      </p>
    </article>
  </main>

  <footer class="text-center">
    <p>Deanna Warren (2015)</p>
  </footer>

    <script src="bower_components/jquery/dist/jquery.min.js"></script>
    <script src="bower_components/foundation/js/foundation.min.js"></script>
    <script src="js/app.js"></script>
  </body>
</html>
